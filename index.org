#+STARTUP: indent
#+OPTIONS: toc:nil
#+OPTIONS: title:nil
#+TITLE: Quake Emacs
#+DESCRIPTION: The modern, single-file, vanilla-first Emacs anti-distribution
#+HTML_HEAD:     <meta property="og:image" content="https://raw.githubusercontent.com/alexispurslane/quake-emacs/main/banner-quake.png" />

#+begin_export html

<style>
body {
    max-width: 65ch;
    padding: 15px;
    font-family: sans-serif;
    margin: 0 auto;
    background-color: #282828;
    color: white;
}

blockquote {
  border-left: 10px solid #665C54;
  margin: 1.5em 10px;
  padding: 0.5em 10px;
  quotes: "\201C""\201D""\2018""\2019";
}

blockquote p {
  display: inline;
}

pre {
    background-color: #32302F;
    color: white;
    border: 1px solid #665C54;
}

a {
    color: #FABD2F;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

a:visited {
    color: #EEBD35;
}

p {
    text-align: justify;
}

img {
    display: block;
    margin-left: auto;
    margin-right: auto;
    max-height: 300px;
}
</style>

<div align="center">
  <img src="https://raw.githubusercontent.com/alexispurslane/quake-emacs/main/banner-quake.png" height="128" style="display: block; margin: 0 auto"/>
  
  <h1>Quake Emacs</h1>
  
  <p style="text-align: center;">Lean, fast, focused, and based on the latest Emacs tech</p>
    <img src="https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/badge.svg"/>
  <br/>
  <a href="https://github.com/alexispurslane/quake-emacs">
    <img src="https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white"/>
  </a>
</div>
#+end_export

--------------

#+begin_export html
  <p align="center">
  <img src="https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/dashboard.png" width="25%"/>
  </p>
#+end_export

Quake Emacs is a single-file [[https://www.gnu.org/software/emacs/][Emacs]] distribution aiming to provide the "just works out of the box" experience and opinionated, sane defaults of an editor like [[https://helix-editor.com/][Helix]] or [[https://github.com/doomemacs/doomemacs][DOOM Emacs]], while remaining as minimal a layer of abstraction as possible on top of Emacs, enhancing, rearranging, and /deeply/ integrating with the plethora of powerful capabilities already available in vanilla Emacs to make something that's great to use, instead of reinventing the wheel or building an entirely new editor on top. 

If you want to use Emacs, but you:

1. just want to sit down and have your new text editor work well and look good /right away/, and
2. don't want the complexity, abstraction, and lack of documentation of a larger Emacs distribution or configuration framework,

then Quake Emacs is for you.

** Table of Contents                                               :TOC_3_org:
  - [[Key Features][Key Features]]
  - [[Justification][Justification]]
  - [[Showcase][Showcase]]
    - [[Simple Config][Simple Config]]
    - [[Code Editing][Code Editing]]
    - [[Writing][Writing]]
    - [[Note-taking][Note-taking]]
  - [[How To Install][How To Install]]
  - [[Supported Languages][Supported Languages]]
    - [[Language Server][Language Server]]
    - [[Tree Sitter Grammar][Tree Sitter Grammar]]
    - [[Tree Sitter Mode][Tree Sitter Mode]]
    - [[Built-In Language Support Matrix][Built-In Language Support Matrix]]
  - [[Personal Configuration and Extra Layers][Personal Configuration and Extra Layers]]
  - [[God Mode Keybindings][God Mode Keybindings]]
  - [[Inspiration and Prior Art][Inspiration and Prior Art]]
    - [[Doom Emacs][Doom Emacs]]
    - [[MinEmacs][MinEmacs]]
    - [[Emacs Prelude][Emacs Prelude]]
- [[Footnotes][Footnotes]]

** Key Features
- üéØ *Lean and focused*: Quake Emacs includes only the packages and configuration needed for a beautiful and modern coding experience, a distraction-free writing experience, and a powerful note-taking experience. It even mostly does away with the need for large language-specific collections of packages through the use of tree-sitter and LSP support! Consider Quake Emacs part of your editor, just there to give you a good out of the box experience to jump off from and make your own.

- üöÄ *Fast*: On my machine, Quake Emacs loads in under 0.38 seconds. Every single package is carefully chosen with performance in mind, and the default load order is tuned obsessively to ensure Emacs starts as fast as possible. Enjoy fast startup times, or use it as extra headroom to add your own packages.

- ü•á *Just one single file*: The Quake code itself is only one simple, extensively documented, self-contained 1000-line file. That's it. Just put the file in your Emacs directory and go. No external commands, no multiple thousands of lines of Lisp scattered throughout hundreds of files across interminable layers of abstraction. If you want to know where something is, or how it works, it's easy to find.

- üåê *Modern and vanilla*: Despite having an opinionated UX out of the box, Quake Emacs prioritizes [[https://b.tuxes.uk/avoiding-emacs-bankruptcy.html][using Emacs's built-in capabilities plus packages that integrate well with them]] as much as feasibly possible. No more extra layers of abstraction, no more dozens or hundreds of redundant packages, no more complex configuration to integrate everything, and no more Emacs documentation not applying to you because of the Emacs distribution you're using. Quake Emacs even uses [[https://github.com/emacsorphanage/god-mode][god-mode]] to provide the ergonomic benefits of modal editing *while reusing all of Emacs's default keybindings and mnemonics*, so all existing documentation for Emacs will still be usable for you!

** Justification

With the introduction of various modern Emacs features in the last few years, and the emergence of a new generation of Emacs packages focused on integrating with vanilla Emacs, Emacs distributions as we have known them are less and less relevant.

Now that =use-package= is included with Emacs by default, configuration frameworks are less necessary then ever, as vanilla Emacs's newly built-in capabilities for reproducable, declaratively specified package management and organized configuration specification are likely much better than whatever a configuration framework could offer, with the benefit of also being the community standard. In my experience, Doom Emacs's ideosyncratic package management system was less clear, since it depended on state that must partially be managed outside the editor in the form of a terminal command in addition to in-editor state, less-organized, as customization could not naturally be grouped with the packages that customization modified, less-documented, since every exising package provides a =use-package= spec, and =use-package= has an excellent and complete manual, while DOOM's configuration framework is partially documented, and much less reliable than what is now built into Emacs 29.

Likewise, with the inclusion of =eglot= and =tree-sitter=, language-specific "layers" that compose five or six packages (one for navigation, one for refactoring and snippets, one for completion, one for syntax highlighting, one for linting, etc), together with a lot of configuration, in order to give a decent experience, are mostly a thing of the past. One tree-sitter mode may still need to be provided, but these can be very simple and direct mappings from an AST to font locking and syntax tables, simple enough that a huge breadth of them can eventually be included by default in Emacs. Quake Emacs leverages these powerful built-in modern Emacs features to give you the experience of an Emacs configuration framework and distribution, without all the complexity.

Additionally, while one of the major problems with most tree sitter structural editing modes in Emacs that we've seen so far, such as [[https://github.com/mickeynp/combobulate][Combobulate]] and [[https://github.com/ethan-leba/tree-edit][tree-edit]], is that they must maintain their own library of syntax tree queries for various navigation motions and text objects, and their commands become useless outside of the relatively limited set of languages that have tree sitter support, if you build structural editing support on top of Emacs's [[https://dawranliou.com/blog/structural-editing-in-vanilla-emacs/][built in structural editing commands]], which use Emacs major mode syntax tables, then those structural editing commands are always going to be present and at least somewhat useful wherever you go and whatever language you're editing, so you can begin to truly integrate them into your editing vocabulary, and they can automatically use either tree sitter, when it's available, or old fashioned regular expressions when it's not, since syntax tables abstract out the specific parsing logic being used and tree sitter modes implement them automatically in terms of the tree sitter syntax tree whereas regular modes use regexes. This also means that one does not have to maintain a custom tree sitter query library for each language, but instead can just rely on the queries each Emacs tree sitter mode already implements for syntax highlighting and the syntax table via Emacs's existing structural commands, decreasing maintenence burden and increasing versitility![fn:1] Thus, Quake Emacs uses [[https://github.com/AmaiKinono/puni][puni]] to add structural editing, taking maximal advantage of tree sitter /by leveraging already exising vanilla Emacs features!/

Similarly, with the creation of amazing packages like =orderless=, =marginalia= and =corfu=, the need to manually integrate added features from various packages into your Emacs system and other Emacs packages is basically obsolete: these packages integrate directly with Emacs, by hooking into or outright replacing Emacs's built in functions for performing various actions, so there's no need to do anything. No more need for packages to hard-code integration with your completion framework, for instance, as they did with =company-mode=; instead, =corfu= can just hook into =completion-at-point-functions= at work out of the box, for instance. As a result, much of the configuration work Emacs distributions needed to do to wire everything up simply doesn't need to be done. Likewise, since =icomplete-vertical= got integrated into Emacs, and Protesilaos Stavrou discovered how to make it usable by turning off all the delays and timers built in, Emacs doesn't even need a vertical live fuzzy completion minibuffer framework like Helm or even Vertico anymore, it has one built in!

** Showcase

#+begin_quote
‚ö†Ô∏è Note: I'm still using evil keybindings instead of =god-mode= in these gifs, but it took hours to record them, so I'm not going to fix them.
#+end_quote

*** Simple Config
Before I get to showing you any of the fancy things Quake Emacs can do, the most important thing is proving that it will be manageable for you to understand and fork if necessary, and won't lead either you or me to Emacs bankruptcy. One of the key things I've done in this regard is optimizing the layout of =init.el= to work with Emacs's built-in =outline-minor-mode= to help you get an overview of it and jump to specific things in it without needing finnicky text search or getting overwhelmed:

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/outline-mode-compat.gif]]

It's much more difficult to demonstrate code clarity and simplicity in a gif, though, so if you're still skeptical, I highly encourage you to skim the [[https://github.com/alexispurslane/quake-emacs/blob/develop/init.el][source code]] yourself.

#+begin_quote
‚ö†Ô∏è Why isn't this a literate config? I've seriously considered it for code clarity reasons, but decided against it for a number of reasons:

1. First, as a literate config, I'd want to move all the per-layer documentation out of docstrings and into the org mode markup to avoid tedious duplication, but then eldoc wouldn't document layers for you.
2. Second, it would mean Quake Emacs would really be two files, instead of one and a user file, which is annoying. I do want it to be as self-sufficient as possible. In fact, I'm planning on making the user file optional.
3. Third, it adds a layer of indirection and complexity that goes against the core goal of Quake Emacs: with a literate config, I'd have to use org-tangle to 'compile' it before it could be loaded into Emacs, and it would be possible for the literate config and the tangled config to get out of sync locally, not to mention needing to use {C-c '} to edit the blocks.
4. And fourth, it would probably significantly slow start times, since =load=ing is slow, and I want to avoid that. However, I've tried to get as close to what a literate configuration file would offer by other means

Feel free to open an issue if you think this was a bad choice, though!
#+end_quote

*** Code Editing
Quake Emacs has fuzzy autocompletion with [[https://elpa.gnu.org/packages/doc/corfu.html][Corfu]] and Orderless enabled everywhere.

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/fuzzy-autocompletion-everywhere1.gif]]

Full autocompletion even works in the Lisp Eval line (=M-:=). It's a real repl, so why not have a real coding experience in it?

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/fuzzy-autocompletion-everywhere2.gif]]

We also have a vertical fuzzy searching UI for popups, with live narrowing, like you're used to in other modern editors, available *using Emacs's built-in completion UI*, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Icomplete.html][Icomplete]]! No need for Vertico now that we have =icomplete-vertical-mode= and the ability to tweak icomplete's existing settings to remove all the limits and delays, and especially since [[https://github.com/oantolin/orderless][Orderless]], [[https://github.com/minad/marginalia][Marginalia]], and [[https://github.com/minad/consult][Consult]] integrate with vanilla Emacs's existing functions and capabilities, so anything tha makes use of them is automatically enhanced!

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/fuzzy-searching-everywhere.gif]]

Quake Emacs also features [[https://github.com/abo-abo/hydra?tab=readme-ov-file][which-key]] for more discoverable keybindings, and [[https://github.com/emacsorphanage/god-mode][god-mode]] for ergonomic modal editing while remaining fully compatible with vanilla Emacs -- all the same mnemonics, commands, and concepts are available, you can just access them without twisting your fingers into pretzels!

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/which-key-leader-key.gif]]

Quake Emacs also provides IDE class-features thanks to LSP support via [[https://github.com/joaotavora/eglot][Eglot]] and [[https://github.com/casouri/eldoc-box][eldoc-box]], highly automatic [[https://www.emacswiki.org/emacs/Tree-sitter][tree-sitter]] support with [[https://github.com/renzmann/treesit-auto][treesit-auto]], inline errors and linting and even quick-fixes with Eglot's integration with Flymake, and advanced language-agnostic debugging with [[https://github.com/svaante/dape][DAPE]]. Here's just LSP and eldoc-box (and tree-sitter's syntax highlighting) on display:

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/ide-class-features.gif]]

Quake Emacs also comes with [[https://github.com/AmaiKinono/puni][puni]], a vanilla-Emacs-first structural editing package similar to the more popular [[https://github.com/Fuco1/smartparens][Smartparens]] but using Emacs's built in syntax tables and structural editing commands instead of requiring complex language-specific logic. For more on what that looks like in practice, click the link to puni above.

And, Quake Emacs wouldn't be able to live up to its name unless it had a classic Quake-style popup terminal! So here it is, implemented entirely without any external packages, and bound to =SPC ~=:

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/quake-term.gif]]

*** Writing
For those of you who prefer to write your prose in Emacs, I've also created an excellent writing mode, which switches to [[https://github.com/iaolo/iA-Fonts/tree/master][a variable pitch font]] of your choice, enables a [[https://github.com/joaotavora/darkroom][distraction-free writing mode]], and enables [[https://github.com/joostkremers/visual-fill-column][visual fill column mode]] wrapped at 65 characters so that lines behave pleasingly like in a WYSIWYG editor:

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/proselint-enabled-writing-mode.png]]

Writing mode also enables a flymake [[https://github.com/amperser/proselint][proselint]] backend to help you improve your prose:

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/proselint-up-close.png]]

To enable all of that, just use =SPC o d=!

Lusting after the capabilities of [[https://www.gnu.org/software/hyperbole/][GNU Hyperbole]] but not so sure about such a gigantic package, that doesn't integrate well with Emacs's standard UI? Quake Emacs has [[https://github.com/oantolin/embark][Embark]] by default, to imbue all your text buffers with meaning and actions without any need for explicit syntax or buttonization. Now every text buffer is an active hypertext experience!

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/embark.gif]]

*** Note-taking
For those that want Emacs to serve as their note-taking machine, Quake Emacs uses [[https://protesilaos.com/emacs/denote][Denote]], a lightweight personal hypertext information manager that offers all of the same basic features as =org-roam=, without locking you down to using only Org, or requiring you to use an SQLite database, while also offering optional excellent integration with org if you want it. It can incorporate an extensible list of markup languages instead of just org and markdown, or even non-text-markup files directly into its linking and searching system. Moreover, it also makes deep use of existing Emacs built-ins, as well as integrating explicitly with packages like marginalia, and consult (via [[https://github.com/mclear-tools/consult-notes][consult-notes]]). And of course I've created a set of convenient leader key keybinds for managing it.

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/denote.png]]

I've also unlocked the power of having your code editor, word processor, and note-taking application all be one and the same through enabling global [[https://github.com/protesilaos/denote/issues/364][buttonization and insertion of denote links]]. Now *you can link to your notes from any file you open, no matter where it is or what file type it is.* Want to keep a huge library of notes on your various projects and link to them in the comments of your code? Now you can.

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/denote-global-links.png]]

Want to have several separate Zettelkasten for different projects? I've created a [[https://github.com/protesilaos/denote/issues/367][custom command]] that allows you to automatically create a new denote silo and add it to =project.el=, so you can manage your silos just like any other project without having to put them in version control.

[[https://raw.githubusercontent.com/alexispurslane/quake-emacs/image-data/denote-note-project.png]]

** How To Install

Convinced?

1. First, install the Quake Emacs project directly to your Emacs configuration directory, so Quake can take over your Emacs installation:

   #+begin_src sh
   git clone --depth=1 -b main https://github.com/alexispurslane/quake-emacs.git ~/.emacs.d
   #+end_src

2. Then copy the example =user.el= provided with Quake to your Quake Emacs configuration directory at =~/.quake.d/user.el=:

   #+begin_src sh
   mkdir -p ~/.quake.d/ && cp ~/.emacs.d/user.el ~/.quake.d/
   #+end_src

   To update, just =git pull= to the latest tag. I recommend you check the release notes for the tag for any tips, known issues to avoid, etc.

3. Once the directories are set up, simply launch Emacs and it should begin downloading and installing the packages that make up Quake Emacs, as well as configuring them. Installation is idempotent, and the install process can take some time, so feel free to close Emacs anytime you need to ‚Äî it will pick up where it left off next time!

4. Once Quake Emacs has installed and configured all its packages, the next step will be making sure it supports the languages you want to work in, which leads us to the next section...

** Supported Languages

Three things are required for Quake Emacs to support a language using the modern language support facilities built in to it:

*** Language Server

Your language server, of course, does not need to be installed within Quake Emacs. It is an independent program you will need to install on your host system to a [[https://www.emacswiki.org/emacs/ExecPath][path]] Emacs knows to look in for executables, at which point Quake Emacs's LSP package, Eglot, will probably be able to detect your language server automatically.

If Eglot cannot automatically detect your LSP, [[https://www.gnu.org/software/emacs/manual/html_mono/eglot.html#Setting-Up-LSP-Servers][it is easy to specify a custom language server for a given mode]].

Some languages, such as Common Lisp (SLIME/SLY) and Clojure (CIDER) have their own alternatives to a language server that you should use instead.

*** Tree Sitter Grammar

Tree sitter grammars are also technically external to Quake Emacs, since they are dynamic libraries that are loaded in at runtime; however, Quake Emacs's tree sitter support package expects them to be installed in a specific location by default (=~/.emacs.d/tree-sitter/=), and through the use of =treesit-auto=, Quake Emacs has a fairly large set of tree sitter grammers it knows how to automatically install from within the editor (please consult the language support matrix at the bottom of the parent section).

If =treesit-auto= does not have an auto-install recipe for the language you wish to use, simply use the built-in command =treesit-install-language-grammar= and follow the easy-to-understand prompts to install the grammar you want. After that, you should be all set!

*** Tree Sitter Mode

In order for Emacs to be able to interpret the meaning of the concrete syntax tree generated by the tree sitter grammar, it needs a tree-sitter mode for that language, to translate the syntax tree into font locking and syntax tables and so on. These are generally fairly simple to write, so a fair number of them are already built into Emacs, and more are being added over time (six in Emacs 30.1 alone!).

Nevertheless, some packages may need to be [[https://www.gnu.org/software/emacs/manual/html_mono/use-package.html#Installing-packages][added to your user.el]] instead (remember to use =use-package :ensure t=, as the documentation link explains, instead of =package-install=, so that your configuration is reproducable on other machines).

For information on which are built into Emacs and which are not, please consult the language support matrix below.

*** Built-In Language Support Matrix

This matrix shows the list of languages that Quake Emacs has *built-in* support for in some capacity, and to what capacity that's true. There are many more languages that have tree-sitter modes available for them, and still more languages that Emacs supports in the traditional way, which can also be installed with =use-package= as mentioned above.

| Language   | Tree-Sitter Mode Built In? | Tree-Sitter Grammar Auto Install? |
|------------+----------------------------+-----------------------------------|
| Bash       | ‚úÖ                         | ‚úÖ                                |
| PHP        | ‚úÖ                         | ‚ùå                                |
| Elixir     | ‚úÖ                         | ‚úÖ                                |
| HEEx       | ‚úÖ                         | ‚úÖ                                |
| HTML       | ‚úÖ                         | ‚úÖ                                |
| LUA        | ‚úÖ                         | ‚úÖ                                |
| C++        | ‚úÖ                         | ‚úÖ                                |
| C          | ‚úÖ                         | ‚úÖ                                |
| CMake      | ‚úÖ                         | ‚úÖ                                |
| C#         | ‚úÖ                         | ‚úÖ                                |
| CSS        | ‚úÖ                         | ‚úÖ                                |
| Dockerfile | ‚úÖ                         | ‚úÖ                                |
| Go         | ‚úÖ                         | ‚úÖ                                |
| Java       | ‚úÖ                         | ‚úÖ                                |
| JS         | ‚úÖ                         | ‚úÖ                                |
| JSON       | ‚úÖ                         | ‚úÖ                                |
| Python     | ‚úÖ                         | ‚úÖ                                |
| Ruby       | ‚úÖ                         | ‚úÖ                                |
| Rust       | ‚úÖ                         | ‚úÖ                                |
| TOML       | ‚úÖ                         | ‚úÖ                                |
| TSX        | ‚úÖ                         | ‚úÖ                                |
| TypeScript | ‚úÖ                         | ‚úÖ                                |
| Yaml       | ‚úÖ                         | ‚úÖ                                |
| awk        | ‚ùå                         | ‚úÖ                                |
| bibtex     | ‚ùå                         | ‚úÖ                                |
| blueprint  | ‚ùå                         | ‚úÖ                                |
| clojure    | ‚ùå                         | ‚úÖ                                |
| commonlisp | ‚ùå                         | ‚úÖ                                |
| dart       | ‚ùå                         | ‚úÖ                                |
| glsl       | ‚ùå                         | ‚úÖ                                |
| janet      | ‚ùå                         | ‚úÖ                                |
| julia      | ‚ùå                         | ‚úÖ                                |
| kotlin     | ‚ùå                         | ‚úÖ                                |
| latex      | ‚ùå                         | ‚úÖ                                |
| magik      | ‚ùå                         | ‚úÖ                                |
| make       | ‚ùå                         | ‚úÖ                                |
| markdown   | ‚ùå                         | ‚úÖ                                |
| nix        | ‚ùå                         | ‚úÖ                                |
| nu         | ‚ùå                         | ‚úÖ                                |
| org        | ‚ùå                         | ‚úÖ                                |
| perl       | ‚ùå                         | ‚úÖ                                |
| proto      | ‚ùå                         | ‚úÖ                                |
| r          | ‚ùå                         | ‚úÖ                                |
| scala      | ‚ùå                         | ‚úÖ                                |
| sql        | ‚ùå                         | ‚úÖ                                |
| surface    | ‚ùå                         | ‚úÖ                                |
| typst      | ‚ùå                         | ‚úÖ                                |
| verilog    | ‚ùå                         | ‚úÖ                                |
| vhdl       | ‚ùå                         | ‚úÖ                                |
| vue        | ‚ùå                         | ‚úÖ                                |
| wast       | ‚ùå                         | ‚úÖ                                |
| wat        | ‚ùå                         | ‚úÖ                                |
| wgsl       | ‚ùå                         | ‚úÖ                                |

If you want support for another language, one place to start is [[https://github.com/search?q=-ts-mode+emacs&type=repositories][the list of =-ts-mode=s available for Emacs on GitHub]].

** Personal Configuration and Extra Layers

When writing custom configuration in your =user.el=, it is recommended that you separate your configuration out into logical groups according to general purpose, with each group contained within a function (and preferably with everything within those functions/groups bundled neatly into =use-package= declarations). This is precisely what Quake Emacs does ‚Äî we call these logical units "layers", after the fashion of Doom Emacs and Spacemacs, although they're just regular functions, no boilerplate necessary ‚Äî and it has a few benefits:

1. It means that your code is easier to fold and navigate with imenu without even needing to insert outline headlines, and easier to document in an accessible way, since you gain the ability to attach docstrings not just to individual utility functions or =use-packages=, but to logical groups of things, so you can document what you're doing and why at a higher level, essentially reproducing much of the benefit of a literate config.
2. It just means your code is more logically and neatly organized, the better to avoid Emacs bankruptcy.
3. Finally, it means that you can take advantage of Quake Emacs's existing logic for running layers, and slot your own code neatly anywhere you want in the Quake Emacs load order, in case you need to run before some things but after others, without having to modify the core =init.el= or do any other hacks.

Out of the box, Quake Emacs contains only the layers that you will absolutely need for a good general-purpose writing, note taking, and code editing experience, as explained above. However, if you find yourself needing more functionality, in addition to writing your own layers, I have a few Gists containing some layers I've constructed for personal use, here, which you can either use yourself, or treat as examples of how to write Quake Emacs layers:

| Layer Name             | Layer Description                                                                                                                                                                                                                                               |
|------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [[https://gist.github.com/alexispurslane/73980e92173d5cb85f2b644734c265ba][org-static-blog-layer]]  | Use org-mode and Emacs to directly generate your blog, no external programs needed! Have your blog wherever you have your editor!                                                                                                                               |
| [[https://gist.github.com/alexispurslane/93c35dcfc910088016e0603aec9b24e0][eshell-layer]]           | Modernize eshell, for those used to modern shells like Fish and Nushell, or heavily extended Zsh.                                                                                                                                                               |
| [[https://gist.github.com/alexispurslane/28be85797872fcc3fda80e2aa973903c][gnus-proton-mail-layer]] | Use GNUS to send (asynchronously!) and receive mail with Proton Mail.                                                                                                                                                                                           |
| [[https://gist.github.com/alexispurslane/f60785a3895dd1d4487717e56f93349c][tramp-distrobox-layer]]  | Use TRAMP with Distrobox (for immutable distros mainly)                                                                                                                                                                                                         |
| [[https://gist.github.com/alexispurslane/fe520a69210fbe5e0462be39c351a370][devil-layer]]            | A basic set of Doom/Spacemacs style leader-key keybindings to get you started. (Quake Emacs has switched to god-mode and a package that makes god-mode behave like a leader key, because it's more compatible with vanilla emacs, and much easier to maintain.) |
| evil-layer             | Not part of the core Quake Emacs distribution, but probably common enough of a desiderata that it is provided in the main repo instead of a Gist. Enables evil mode and evil collection, and switches god mode to work as a leader key using evil-god-mode. |

#+begin_quote
‚ö†Ô∏è If you write a layer you think might be generally  useful to others, as long as it is reasonably small and self-contained, you are more than encouraged to submit a PR on this readme so we can add it to the list!
#+end_quote

** God Mode Keybindings

#+begin_quote
 ‚ö†Ô∏è You can find a guide to reading Emacs keybinding notation [[https://riptutorial.com/emacs/example/19969/key-bindings-notation][here]].
#+end_quote

For those who want to dabble in the ergonomic benefits of modal editing -- avoiding all those nasty key chords -- Quake Emacs provides [[https://github.com/emacsorphanage/god-mode][=god-mode=]], which can be activated by hitting =ESC= in any Emacs buffer, and deactivated to return to regular Emacs mode using =i=. God mode essentially provides a language for translating un-chorded keystrokes into Emacs's already-existing chorded ones -- think of it like a smarter, more automatic version of sticky keys. This can save your fingers and carpel tunnels a lot of stress if you have pre-existing RSI. Crucially, it does not define any of its own keybindings, or reinvent the wheel in any way; it automatically uses all of [[http://xahlee.info/emacs/emacs/gnu_emacs_keybinding.html][Emacs's built in keybindings]] and any created by you or any package, keeping the form and mnemonics exactly the same, only allowing you to avoid the key modifiers.

The translation is pretty simple. Allow me to quote the god-mode documentation:

#+begin_quote
This package defines the following key mappings:

- All commands are assumed to use the control modifier (=C-=) unless 
  otherwise indicated. Here are some examples:

   - =x=‚ÄÉ‚Üí‚ÄÉ=C-x=
   - =f=‚ÄÉ‚Üí‚ÄÉ=C-f=
   - =x= =s=‚ÄÉ‚Üí‚ÄÉ=C-x= =C-s=
   - =x= =SPC= =s=‚ÄÉ‚Üí‚ÄÉ=C-x= =s=

   Note the use of the space key (=SPC=)
   to produce =C-x= =s=.

- The literal key (=SPC=) is sticky. This means you don't have to enter 
  =SPC= repeatedly for key bindings such as =C-x= =r= =t=.
  Entering the literal key again toggles its state.
  The literal key can be changed through `god-literal-key`. Here are some examples:
  
   - =x= =SPC= =r= =t=‚ÄÉ‚Üí‚ÄÉ=C-x= =r= =t=
   - =x= =SPC= =r= =SPC= =g= =w=‚ÄÉ‚Üí‚ÄÉ=C-x= =r= =M-w=

- =g= is used to indicate the meta modifier (=M-=). This means
  that there is no way to enter =C-g= in God mode, and you must
  therefore type in =C-g= directly. This key can be changed through
  `god-mode-alist`. Here are some examples:

   - =g= =x=‚ÄÉ‚Üí‚ÄÉ=M-x=
   - =g= =f=‚ÄÉ‚Üí‚ÄÉ=M-f=

- =G= is used to indicate both the control and meta modifiers
  (=C-M-=). This key can also be changed through `god-mode-alist`. Here
  are some examples:

   - =G= =x=‚ÄÉ‚Üí‚ÄÉ=C-M-x=
   - =G= =f=‚ÄÉ‚Üí‚ÄÉ=C-M-f=

- Digit arguments can also be used:

  - =1= =2= =f=‚ÄÉ‚Üí‚ÄÉ=M-12= =C-f=

- If you use some of the [useful key bindings][useful-key-bindings],
  =z= or =.= can repeat the previous command:

  - =g= =f= =.= =.=‚ÄÉ‚Üí‚ÄÉ=M-f=
    =M-f= =M-f=

- Universal arguments can also be specified using =u=:

  - =u= =c= =o=‚ÄÉ‚Üí‚ÄÉ=C-u= =C-c=
    =C-o=
#+end_quote

Quake Emacs also defines several additional keybindings beyond the ones that Emacs has by default, for the various things it adds. To understand the following list, remember that its form reflects the fact that in Emacs all keybindings are a tree of key chords, navigated by pressing successive key chords.

- =C-c n= :: Notes
  - =s= :: =denote-silo=
  - =c= :: =org-capture=
  - =l= :: =org-store-link=
  - =n= :: =consult-notes=
  - =i= :: =denote-link-global=
  - =I= :: =denote-link-after-creating=
  - =r= :: =denote-rename-file=
  - =k= :: =denote-keywords-add=
  - =K= :: =denote-keywords-remove=
  - =b= :: =denote-backlinks=
  - =B= :: =denote-find-backlink=
  - =R= :: =denote-region=
- =C-c &= ::  Code Snippets
  - =n= :: =yas-new-snippet=
  - =s= :: =yas-insert-snippet=
  - =v= :: =yas-visit-snippet-file=
- =C-c p= :: Profile Management
  - =t= :: =consult-theme=
  - =f= :: open framework config
  - =u= :: open user config
  - =r= :: =restart-emacs=
  - =l= :: Reload user config
- =C-c o= :: Open Tools
  - =w= :: =eww=
  - =a= :: =org-agenda=
  - === ::  =calc=
  - =s= ::  open new shell
  - =-= ::  =dired=
  - =T= ::  =treemacs=
  - =t= ::  =toggle-frame-tab-bar=
  - =m= ::  =gnus-other-frame=
  - =d= ::  =word-processing-mode=
  - =S= ::  =scratch-window-toggle=
- = = :: Top Level Keybindings
  - =C-~= :: =shell-toggle=
  - =C-:= :: =pp-eval-expression=
  - =C-;= :: =execute-extended-command=
- =C-x= :: File, Buffer, and Project Manipulation
  - =C-x= :: =delete-file=
  - =C-X= :: =delete-directory=
  - =K= :: =kill-current-buffer=
  - =B= ::  =ibuffer=
  - =p E= :: =flymake-show-project-diagnostics=
- =C-c l= :: LSP Server
  - =E= :: =flymake-show-buffer-diagnostics=
  - =e= :: =consult-flymake=
  - =s= :: =eglot=
  - =a= :: =eglot-code-actions=
  - =r= :: =eglot-rename=
  - =h= :: =eldoc=
  - =f= :: =eglot-format=
  - =F= :: =eglot-format-buffer=
  - =R= :: =eglot-reconnect=
- =C-h= :: Helpful Docs
  - =v= :: =helpful-variable=
  - =f= :: =helpful-callable=
  - =k= :: =helpful-key=
  - =x= :: =helpful-command=
- =C-w= :: Window Management
  - =C-w=      :: =vil-window-map=
  - =C-w C-u=  :: =winner-undo=

For true modal editing enthusiasts who want a full text editing grammar, not just a way to avoid key chords, I recommend checking out my package [[https://github.com/alexispurslane/prometheus-mode][=prometheus-mode=]].

** Inspiration and Prior Art
*** Doom Emacs
[[https://github.com/doomemacs/doomemacs][DOOM Emacs]] was my previous (and fallback) daily driver. It is an excellent Emacs distribution and piece of software, but essentially its own editor in many ways. Still what I would probably recommend to a newbie until Quake hypothetically becomes stable and mature.

**** Points of similarity:
1. Opinionated and aesthetically pleasing defaults to try to make Emacs look and feel, not like another editor like VSCode, but like a /modern Emacs/ --- unique, but not recalcitrant.
2. Obsessive attention to performance, because one of the main benefits of Emacs is providing a powerful editing experience comparable or vastly superior to something like VSCode, while still relatively having the performance and lightweight footprint of a terminal application.

**** Differences:
1. Doesn't install nearly as many packages and does fewer (no) ideosyncratic things. This gives you less of a complete experience you aren't supposed to tinker with besides toggling layers, and more of a comfortable and usable-out-of-the-box, but relatively simple and straightforward, foundation to build from.
2. Has no "alternate" layers to achieve the same functionality in different ways (e.g.¬†helm vs ivy vs vertico). There is one blessed set of packages, to avoid the combinatorial explosion of complexity that brings.
3. Will not have any layers, packages, and configuration available or installed for anything outside of making what I consider core text editor functionality nice to use (so nothing for mail, no vterm, etc).
4. Offers no customization framework or anything bespoke, only Vanilla Emacs constructs.
5. Fully adopts modern Emacs features, including =treesit=, =eglot=, =use-package=, and even =electric-pair= (Doom Emacs is strugglign with this)
6. Will never have language-specific layers, uses =eglot= and =treesit= for generally excellent language support.
7. No complex external terminal commands for management.
8. Has hard complexity and size limits: one 1000-line file, less than a second of startup time even with all layers enabled.
9. DOOM Emacs focuses on building essentially a whole new editor on top of Emacs using evil mode, instead of helping you use and learn and get familiar with Emacs's own text editing ideas, commands, and features. Quake Emacs uses =god-mode= to make Emacs's existing commands and ideas more ergonomically accessible (my RSI makes key chords painful).

*** MinEmacs
I have not personally used MinEmacs, but I rifled fairly extensively through its codebase to borrow ideas, tips, tricks, and so on, and read its mission statement and looked at the screenshots.

**** Points of similarity:
1. Primarily one user's config, generalized into a general distribution, but not designed to automatically provide for use-cases or configurations wildly separate from the author's own.
2. Desiring to be more minimal and closer to "bare metal Emacs."
3. When starting out, Quake Emacs used MinEmacs's leader key keybindings as a basis, although they've diverged a fair amount by now.

**** Differences:
1. Far less complexity and fewer layers of abstraction, provides NO "configuration framework," NO custom standard library, nothing like that.
2. Different opinionated design decisions (not based on NANO Emacs's design philosophy)
3. No language-specific layers

*** Emacs Prelude
[[https://prelude.emacsredux.com/en/latest/][Emacs Prelude]] seems to be the most philosophically similar Emacs distribution to Quake Emacs. They share many goals and have very similar approaches. You could perhaps think of Quake Emacs as a more modern, and slightly more opinionated, take on Prelude!

**** Points of similarity:
1. Shared goals:

2. Simplicity
3. Ease of understanding and direct modification (not just tweaking)
4. A foundation for you to build upon

2. [@2] Shared practical approaches:

3. Most modules are pretty short and just have essential packages and a few configurations
4. Installs relatively few additional packages (63 at last count)
5. Less opinionated than distributions like Spacemacs or Doom Emacs

**** Differences:
1. Quake installs relatively few packages and vets every single one that /is/ installed for active maintinence, general stability/maturity, etc, like MinEmacs, but still uses much more modern Emacs capabilities and packages, as soon as they /are/ reasonably mature, instead of choosing older packages simply for the sake of longevity.
2. Intended to strike a balance between being a great end-user product out of the box /while also/ being a great foundation to build on.
3. Does not come with a bespoke standard library or configuration framework, it's just pure modern Emacs.
4. Does not make most layers opt-in, since there are so few of them
5. No language specific layers.
7. Focuses on only supporting the latest Emacs.
8. Much greater focus on performance.

* Footnotes

[fn:1] It is interesting to note that Emacs had structural editing commands conceptualizing your code as a syntax tree you can navigate up and down and horizontally across siblings through since the beginning, thanks to the fact that Lisp was easy to parse into a usable syntax tree even on the relatively low powered computers of the past, using less advanced algorithms, whereas Vim essentially exclusively conceptualizes your code as a flat list of flat lists of bytes and nothing more, forcing you to express your movements and selections at a much lower level. This was not a serious disadvantage previously, since most languages until recently couldn't be parsed fast enough reliably enough to make Emacs's structural editing commands generally useful, but now that tree sitter is in play, Emacs has a clear advantage in my opinion -- it already has the basic concepts built into its vocabulary, whereas new concepts and verbs must be integrated into Vim's vocabulary. This is why adding even basic tree sitter structural editing required a large package and a lot of elbow grease in the evil layer on my part, but it's easy as pie for Emacs's tree sitter modes to do it. In a sense, Emacs has been waiting for tree sitter for 40 years!
